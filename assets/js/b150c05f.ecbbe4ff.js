"use strict";(self.webpackChunksrc=self.webpackChunksrc||[]).push([[75],{4557:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>l});var n=t(4848),s=t(8453);const i={title:"Dataset Customization",description:"Run MAC-VO stack on new datasets"},o=void 0,r={id:"Redevelop/NewDataset",title:"Dataset Customization",description:"Run MAC-VO stack on new datasets",source:"@site/docs/03-Redevelop/00-NewDataset.md",sourceDirName:"03-Redevelop",slug:"/Redevelop/NewDataset",permalink:"/wiki/Redevelop/NewDataset",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:0,frontMatter:{title:"Dataset Customization",description:"Run MAC-VO stack on new datasets"},sidebar:"tutorialSidebar",previous:{title:"Extend MAC-VO",permalink:"/wiki/category/extend-mac-vo"},next:{title:"Frontend Network",permalink:"/wiki/Redevelop/NewFrontend"}},d={},l=[{value:"Create a new Dataset (Sequence)",id:"create-a-new-dataset-sequence",level:2},{value:"Creating a New DataFrame",id:"creating-a-new-dataframe",level:2},{value:"Example Usage",id:"example-usage",level:2}];function c(e){const a={admonition:"admonition",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(a.h2,{id:"create-a-new-dataset-sequence",children:"Create a new Dataset (Sequence)"}),"\n",(0,n.jsx)(a.admonition,{type:"info",children:(0,n.jsx)(a.p,{children:'Since the visual odometry runs on a consecutive sequence of images, we use the word "Sequence" interchangeably with "Dataset" in this page and the entire codebase.'})}),"\n",(0,n.jsxs)(a.p,{children:["All the DIY dataset should inherit the ",(0,n.jsx)(a.code,{children:"GenericSequence"}),". Create a new file in under ",(0,n.jsx)(a.code,{children:"./DataLodaer"}),"."]}),"\n",(0,n.jsxs)(a.p,{children:["The ",(0,n.jsx)(a.code,{children:"GenericSequence"})," class is an abstract base class designed to manage datasets in a structured way, enabling easy extension and integration with various types of sequence data. Below is a detailed guide on how to implement and use this class for your datasets."]}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-python",children:'from .SequenceBase import GenericSequence\n\n\nclass MySequence(GenericSequence[SomeDataType]):\n    @classmethod\n    def name(cls) -> str: return "MySeqName"    # Optional\n    \n    def __getitem__(self, local_index: int) -> SomeDataType:\n        # logical index is the index exposed to user and may be affected by multiple \n        # cropping and masking process\n        #\n        # index is the "real" index / the index of dataset before all cropping and\n        # masking operations.\n        index = self.get_index(local_index)\n\n        # Implementation for loading a frame, **Required**\n        return SomeDataType(...)\n'})}),"\n",(0,n.jsx)(a.p,{children:"Requirements"}),"\n",(0,n.jsxs)(a.ul,{children:["\n",(0,n.jsxs)(a.li,{children:["\n",(0,n.jsxs)(a.p,{children:[(0,n.jsx)(a.code,{children:"__getitem__"})," ",(0,n.jsx)(a.strong,{children:"Method (Required):"})," This is an abstract method that must be implemented to load individual frames from the dataset. It returns a DataFrame for the specified index. You can customize your own DataFrame or use the default provided by the library. Custom data frame format must be subclass of ",(0,n.jsx)(a.code,{children:"DataFrame"})]}),"\n"]}),"\n",(0,n.jsxs)(a.li,{children:["\n",(0,n.jsxs)(a.p,{children:[(0,n.jsx)(a.code,{children:"name"})," ",(0,n.jsx)(a.strong,{children:"Method (Optional):"})," This method can be overridden to return a custom name for your dataset type. If left blank, it will default to the class name."]}),"\n"]}),"\n",(0,n.jsxs)(a.li,{children:["\n",(0,n.jsxs)(a.p,{children:["Include your dataset in ",(0,n.jsx)(a.code,{children:"DataLodaer/__init__.py"}),". When you are creating a new yaml file for this dataset, fill the ",(0,n.jsx)(a.code,{children:"name"})," with the class name or the short name you defined in the ",(0,n.jsx)(a.code,{children:"name"}),"."]}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(a.h2,{id:"creating-a-new-dataframe",children:"Creating a New DataFrame"}),"\n",(0,n.jsx)(a.admonition,{type:"warning",children:(0,n.jsxs)(a.p,{children:["If you are working on stereo-visual odometry, the ",(0,n.jsx)(a.code,{children:"SourceDataFrame"})," comes with the MAC-VO original codebase should be sufficient. This section is intended for the case where new sensor modality is added to the pipeline."]})}),"\n",(0,n.jsxs)(a.p,{children:["The ",(0,n.jsx)(a.code,{children:"DataFrame"})," class, located in ",(0,n.jsx)(a.code,{children:"Interface.py"}),", is designed as a base class for data handling, particularly for automating data collation. All new data types that need to be managed by the ",(0,n.jsx)(a.code,{children:"GenericSequence"})," use this class."]}),"\n",(0,n.jsxs)(a.p,{children:["For example, if you need to handle camera data, which typically includes only RGB images, you can create a new calss called ",(0,n.jsx)(a.code,{children:"MyDataFrame"}),". This class inherits from ",(0,n.jsx)(a.code,{children:"DataFrame"})," and requires minimal additional code if it only handles data types such as ",(0,n.jsx)(a.code,{children:"torch.Tensor"}),", ",(0,n.jsx)(a.code,{children:"pp.LieTensor"}),", and ",(0,n.jsx)(a.code,{children:"np.ndarray"})," that are directly supported by the default ",(0,n.jsx)(a.code,{children:"collate"})," method in ",(0,n.jsx)(a.code,{children:"DataFrame"}),". Here is an example:"]}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-python",children:"from .Interface import DataFrame\n\nclass MyDataFrame(DataFrame):\n    def __init__(self, image: torch.Tensor):\n        self.image = image\n    # No need to override the collate method if only handling supported data types\n"})}),"\n",(0,n.jsx)(a.p,{children:(0,n.jsx)(a.strong,{children:"Overriding the Collate Method"})}),"\n",(0,n.jsxs)(a.p,{children:["If you want to create your own collation logic or if you want to handle several attributes collectively, you may choose to override the ",(0,n.jsx)(a.code,{children:"collate"})," method directly."]}),"\n",(0,n.jsx)(a.p,{children:"Example"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-python",children:'from .Interface import DataFrame\n\nclass MyDataFrame2(DataFrame):\n    def __init__(self, image: torch.Tensor, some_random_other_data: str):\n        self.other_data = other_data\n        self.image = image\n    \n    @classmethod\n    def collate(cls, batch: list[Self]) -> Self:\n        # Collate images and other data together\n        return cls(\n            torch.cat([x.image for x in batch], dim=0),\n            "|".join([x.other_data for x in batch])\n        )\n'})}),"\n",(0,n.jsx)(a.p,{children:"This structure allows for flexibility in handling various types of data and ensures that the system can efficiently process batches of data, regardless of their specific attributes or the complexity of the data types involved."}),"\n",(0,n.jsx)(a.h2,{id:"example-usage",children:"Example Usage"}),"\n",(0,n.jsx)(a.p,{children:"Here\u2019s how you can instantiate and use your dataset class:"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-python",children:'dataset = GenericSequence.instantiate("MyDatasetName", root="/path/to/dataset", K=torch.eye(3))\n# Equivalent to the following if name(cls) -> str is not implemented by `MyDatasetName`\ndataset = MyDatasetName(root="/path/to/dataset", K=torch.eye(3))\ndataloader = DataLoader(dataset, batch_size=16, collate_fn=dataset.collate_fn)\n\nfor batch in dataloader:\n    print(batch)\n'})})]})}function h(e={}){const{wrapper:a}={...(0,s.R)(),...e.components};return a?(0,n.jsx)(a,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},8453:(e,a,t)=>{t.d(a,{R:()=>o,x:()=>r});var n=t(6540);const s={},i=n.createContext(s);function o(e){const a=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function r(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),n.createElement(i.Provider,{value:a},e.children)}}}]);